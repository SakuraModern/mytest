1、拷贝目录
2、关于对象流
	ObjectInputStream
	ObjectOutputStream

	重点：
		参与序列化的类型必须实现java.io.Serializable接口。
		并且建议将序列化版本号手动的写出来：
			private static final long seriaVersionUID = 1L;
3、IO + Properties联合使用
	IO流：文件的读和写。
	Properties：是一个Map集合，key和value都是String类型。
4、多线程
	- 什么是进程？什么是线程？
		进程是一个应用程序（一个进程是一个软件）。
		线程是一个进程中的执行场景/执行单元。
		一个进程可以启动多个线程。
	- 对于java程序来说，当在DOS命令窗口中输入：
		java HelloWorld 回车之后。
		会先启动JVM，而JVM就是一个进程。
		JVM再启动一个主线程调用main方法。
		同时再启动一个垃圾回收线程负责看护，回收垃圾。
		最起码现在的IDEA程序中至少有两个线程并发，一个是垃圾回收线程，一个是执行main方法的主线程。
	- 进程和线程是什么关系？
		举个例子：
			阿里巴巴：进程
				马云：阿里巴巴的一个线程
				童文红：阿里巴巴的一个线程
			京东：进程
				刘强东：京东的一个线程
				奶茶妹妹：京东的一个线程
			
			进程可以看做是现实生活当中的公司。
			线程可以看做是公司当中的某个员工。

			注意：
				进程A和进程B内存独立不共享。（阿里巴巴和京东资源不会共享的。）
					魔兽游戏是一个进程
					酷狗音乐是一个进程
					这两个进程是独立的，不共享资源。
				线程A和线程B呢？
					- 在java语言中：线程A和线程B，堆内存和方法区共享。
					  但是栈内存独立，一个线程一个栈。
					- 假设启动10个线程，会有10个栈空间，每个栈和每个栈之间，互不干扰，各自执行各自的，这就是多线程并发。
				火车站，可以看做是一个进程。
				火车站中的每一个售票窗口可以看做是一个线程。
				我在窗口1购票，你可以在窗口2购票，你不需要等我，我不需要等你。
				所以多线程并发可以提高效率。

				java中之所以有多线程机制，目的就是为了提高程序的处理效率。 
	- 思考一个问题：
		使用了多线程机制之后，main方法结束，是不是有很多程序也不会结束。main方法结束之时主线程结束了，主栈空了，其他的栈（线程）可能还在压栈弹栈。
			- 详解见图片
	- 对于单核的CPU来说，真的可以做到真正的多线程并发吗？
		- 对于多核的CPU电脑来说，真正的多线程并发是没问题的。
		- 什么是真正的多线程并发？
			t1线程执行t1的
			t2线程执行t2的
			t1不会影响t2，t2也不会影响t1，这叫做真正的多线程并发。
		- 单核的CPU表示只有一个大脑：
			不能够做到真正的多线程并发，但是可以做到给人一种多线程并发的感觉。对于单核的CPU来说，在某一个时间点上实际上只能处理一件事情，但是由于CPU的处理速度极快，
				线程A：播放音乐
				线程B：运行魔兽游戏
				线程A和线程B频繁切换运行，人类会感觉音乐一直在播放，游戏一直在运行，给我们的感觉是同时并发的。
5、java语言中，实现线程有两个方式，哪两种方式呢？
	java支持多线程机制，并且java已经将多线程实现了，只需要继承就行了。
	第一种方式：编写一个类，直接继承java.lang.Thread，重写run方法。
		定义线程类
		public class MyThread extends Thread {
			public void run() {
			}
		}
		创建线程对象
		MyThread myThread = new MyThread();
		启动线程
		myThread.start();
	第二种方式： 编写一个类，实现java.lang.Runnable接口，实现run方法。
		定义一个可运行的类
		public class MyRunnable implements Runnable {
			public void run() {
			}
		}
		创建线程对象
		Thread thread = new Thread(new MyRunnable());
		启动线程
		thread.start();
	
	注意：第二种方式实现接口比较常用，因为一个类实现了接口，它还可以去继承其它的类，更灵活。
6、关于线程对象的生命周期？
	新建状态
	就绪状态
	运行状态
	阻塞状态
	死亡状态
7、关于线程的调度
	- 常见的线程调度模型有哪些？
		抢占式调度模型
			哪个线程的优先级比较高，抢到的CPU时间片的概率就高一些/多一些。
			java采用的就是抢占式调度模型。
		均分式调度模型
			平均分配CPU时间片，每个线程占有的CPU时间片时间长度一样，平均分配一切平等。
	- java中提供了哪些方法是和线程调度有关系的呢？
		实例方法：
			void setPriority(int newPriority)	设置线程的优先级
			int getPriority()	获取线程的优先级
			最低优先级1
			默认优先级是5
			最高优先级10
			优先级比较高的获取CPU时间片可能会多一些。（但是也不完全是，大概率是多的。）
		静态方法：
			static void yield()	让位方法
			暂停当前正在执行的线程对象，并执行其他线程
			yield()方法都不是阻塞方法，是让当前线程让位，让给其它线程使用。
			yield()方法的执行会让当前线程从“运行状态”回到“就绪状态”。
			注意：在回到就绪指后，有可能还会再次抢到。
		实例方法：
			void join()	- 合并线程
			class MyThread1 extends Thread {
				public void doSome() {
					MyThread2 t = new MyThread2();
					t.join();	// 当前线程进入阻塞，t线程执行，直到t线程结束，当前线程才可以继续。
				}
			}

			clas MyThread2 extends Thread {
			}
	- 关于多线程并发环境下，数据的安全问题。
		以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义、线程对象的创建、线程的启动等，都
	  已经实现完了，这些代码都不需要编写。
		最重要的是：编写的程序需要放到一个多线程的环境运行，更需要关注的是这些数据在多线程并发的环境下是否是安全的。
	- 什么时候数据在多线程并发的环境下会存在安全问题呢？
		三个条件：
			条件1：多线程并发
			条件2：有共享数据
			条件3：共享数据有修改的行为
		满足以上3个条件之后，就会存在线程安全问题。
	- 怎么解决线程安全问题呢？
		当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题，怎么解决这个问题？
			线程排队执行。（不能并发）
			用排队执行解决线程安全问题。
			这种机制被称为：线程同步机制。

			专业术语叫做：线程同步，实际上就是线程不能并发了，线程必须排队执行。

		怎么解决线程安全问题呢？
			使用“线程同步机制”。
		线程同步就是线程排队了，线程排队了就会牺牲一部分效率，数据安全第一位，只有数据安全了，才可以谈效率，数据不安全没有效率的事。
	- 线程同步这块，涉及到这两个专业术语：
		异步编程模型：
			线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁，这种编程模型叫做：异步编程模型，其实就是：多线程并发（效率高）。
		同步编程模型：
			线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，两个线程之间发生了等待关系，这就是同步编程模型，效率较低，线程排队执行。

		异步 --> 并发
		同步 --> 排队
8、java中有三大变量？
	实例变量：在堆中
	静态变量：在方法区中
	局部变量：在栈中
	以上三大变量中：
		局部变量永远都不会存在线程安全问题，因为局部变量不共享（一个线程一个栈），局部变量在栈中，所以局部变量永远都不会共享。
	实例变量在堆中，堆只有一个。
	静态变量在方法区中，方法区只有一个。
	堆和方法区都是多线程共享的，所以可能存在线程安全问题。
9、如果使用局部变量的话：
	建议使用：StringBuilder。
	因为局部变量不存在线程安全问题，选择StringBuilder。
	StringBuffer效率比较低。
	
	ArrayList是非线程安全的。
	Vector是线程安全的。
	HashMap、 HashSet是非线程安全的。
	Hashtable是线程安全的。
10、总结：
	synchronized有两种写法：
		第一种：同步代码块
			灵活
			synchronized(线程对象) {
				同步代码块;
			}
		第二种：在实例方法上使用synchronized
			表示共享对象一定是this
			并且同步代码块是整个方法体
		第三种：在静态方法上使用synchronized
			表示找类锁
			类锁永远只有一把
			就算创建来了100个对象，那类也只有一把
		
		对象锁：1个对象1把锁，100个对象100把锁
		类锁：100个对象，也可能只有一把锁
11、以后开发中应该怎么解决线程安全问题？
	是一上来就选择线程同步吗？
		synchronized
		
		不是，synchronized会让程序的执行效率降低，用户体验不好，系统的用户吞吐量降低，用户体验差，
	在不得已的情况下再选择线程同步机制。

		第一种方案：
			尽量使用局部变量代替“实例变量和静态变量”。

		第二种方案：
			如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享为了。（一个
		线程对应一个对象，100个线程对应100个对象，对象不共享，就没有数据安全问题了。）

		第三种方案：
			如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择synchronized了，线程同步机制。
12、线程这块还有哪些内容？
	- 守护线程
	- 定时器
	- 实现线程的第三种方式：FutureTask方式，实现Callable接口（JDK8新特性）
	- 关于Object类中的wait和notify方法（生产者和消费者模式）
